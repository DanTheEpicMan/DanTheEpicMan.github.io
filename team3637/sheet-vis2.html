<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FRC Schedule v49 (Stable & Fixed)</title>
    <style>
        :root {
            --bg: #121212; --panel: #1e1e1e; --border: #333; --text: #ddd; --accent: #d32f2f;
            --btn-hover: #b71c1c; --highlight-parent: #00e676; --highlight-child: #2979ff;
            --meeting-bg: rgba(255, 255, 255, 0.05);
            --grid-line-color: #444;
            --robot-gold: #ffd700;
            --ruler-width: 40px;
        }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background-color: var(--bg); color: var(--text); margin: 0; display: flex; height: 100vh; overflow: hidden; }
        
        #sidebar { 
            width: 300px; background: var(--panel); border-right: 1px solid var(--border); 
            display: flex; flex-direction: column; padding: 20px; gap: 15px; flex-shrink: 0; z-index: 50; 
            box-shadow: 2px 0 10px rgba(0,0,0,0.5); 
            transition: margin-left 0.3s ease;
        }
        #sidebar.hidden { margin-left: -341px; }

        h2 { margin: 0 0 5px 0; font-size: 18px; color: #fff; }
        .subtitle { font-size: 12px; color: #888; margin-bottom: 10px; }
        .step-box { background: #252525; border: 1px solid #444; padding: 15px; border-radius: 6px; }
        label { font-size: 11px; font-weight: bold; color: #aaa; display: block; margin-bottom: 8px; text-transform: uppercase; }
        input[type="file"] { font-size: 12px; width: 100%; color: #ccc; }
        button.action-btn { display: block; width: 100%; padding: 12px; background: var(--accent); color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 13px; margin-top: 10px; }
        button.action-btn:disabled { background: #444; color: #777; cursor: not-allowed; }
        
        #main-area { position: relative; flex-grow: 1; background: #000; overflow: hidden; display: flex; flex-direction: column; }
        .top-bar { height: 45px; background: #222; border-bottom: 1px solid var(--border); display: flex; align-items: center; padding: 0 10px; justify-content: space-between; z-index: 9999; flex-shrink: 0; }
        
        .sidebar-toggle { background: transparent; border: 1px solid #444; color: #aaa; cursor: pointer; padding: 5px 10px; border-radius: 4px; margin-right: 15px; font-size: 14px; }
        .sidebar-toggle:hover { color: #fff; border-color: #777; }

        .view-controls { display: flex; gap: 5px; height: 100%; }
        .view-tab { padding: 0 15px; height: 100%; border: none; background: transparent; color: #888; cursor: pointer; font-weight: 600; font-size: 13px; border-bottom: 3px solid transparent; }
        .view-tab.active { color: #fff; background: #2a2a2a; border-bottom-color: var(--accent); }
        
        .zoom-controls { display: flex; align-items: center; gap: 10px; font-size: 11px; color: #aaa; margin-right: 10px;}
        .zoom-group { display: flex; align-items: center; gap: 5px; background: #111; padding: 2px 8px; border-radius: 4px; border: 1px solid #333; }
        .zoom-group span { font-weight: bold; color: #fff; }
        input[type=range] { width: 60px; accent-color: var(--accent); cursor: pointer; }

        .legend-item { display: flex; align-items: center; gap: 6px; margin-left: 10px; }
        .dot { width: 10px; height: 10px; border-radius: 2px; }

        #viewport-container { position: relative; flex-grow: 1; overflow: hidden; }
        .view-pane { position: absolute; top: 0; bottom: 0; left: 0; right: 0; display: none; background: #000; }
        .view-pane.active { display: block; }
        
        #combined-view { display: flex; flex-direction: column; height: 100%; }
        
        /* TOP: LOCKED MINI-MAP (Starts at 30%) */
        .cv-top { flex: 0 0 30%; position: relative; background: #111; overflow: hidden !important; min-height: 50px; }
        
        /* DRAG HANDLE */
        #drag-handle {
            height: 8px;
            background: #222;
            border-top: 1px solid #333;
            border-bottom: 1px solid #333;
            cursor: row-resize;
            flex-shrink: 0;
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #drag-handle:hover { background: #333; border-color: #555; }
        #drag-handle::after { content: ''; width: 40px; height: 2px; background: #555; border-radius: 2px; }

        /* BOTTOM: SCROLLABLE */
        .cv-bottom { flex: 1; position: relative; overflow: hidden; display: flex; flex-direction: column; min-height: 50px; }

        .gantt-viewport { width: 100%; height: 100%; overflow: auto; position: relative; white-space: nowrap; }
        .chart-body { position: relative; display: inline-block; vertical-align: top; min-width: 100%; }
        .date-ruler { position: sticky; left: 0; width: var(--ruler-width); background: #000; border-right: 1px solid var(--border); z-index: 100; display: inline-block; vertical-align: top; }
        
        .header-stack { position: sticky; top: 0; z-index: 90; background: var(--bg); height: 55px; margin-left: var(--ruler-width); display: flex; flex-direction: column; }
        .header-row-groups { display: flex; height: 25px; width: 100%; }
        .header-row-cols { display: flex; height: 30px; width: 100%; }

        .group-header { background: #222; border: 1px solid #000; border-right: 1px solid #444; text-align: center; font-weight: bold; color: #fff; height: 25px; line-height: 25px; font-size: 12px; box-sizing: border-box; flex-shrink: 0; overflow: hidden; }
        .col-header { background: #2a2a2a; border-right: 1px solid var(--grid-line-color); border-bottom: 1px solid #444; text-align: center; font-size: 11px; height: 30px; line-height: 30px; overflow: hidden; white-space: nowrap; box-sizing: border-box; font-weight: bold; color: #aaa; flex-shrink: 0; }
        
        .swimlane-container { display: flex; margin-left: var(--ruler-width); position: absolute; top: 55px; bottom: 0; }
        .swimlane { border-right: 1px solid var(--grid-line-color); position: relative; background: transparent; height: 100%; box-sizing: border-box; flex-shrink: 0; }
        
        .tick-container { position: absolute; top: 55px; left: var(--ruler-width); width: calc(100% - var(--ruler-width)); height: 100%; pointer-events: none; }
        .date-tick { position: absolute; width: 100%; text-align: right; padding-right: 3px; font-size: 10px; color: #555; border-top: 1px solid #222; box-sizing: border-box; }
        .date-tick.sat { color: #d32f2f; font-weight: 900; } 
        
        .day-band { position: absolute; left: 0; width: 100%; border-top: 1px solid #222; pointer-events: none; z-index: 0; }
        .day-band.meeting { background: var(--meeting-bg); }
        
        .task-card { 
            position: absolute; background: rgba(50,50,50,0.9); border: 1px solid #555; border-radius: 2px; 
            overflow: visible; 
            z-index: 10; box-sizing: border-box; cursor: pointer; min-height: 20px; 
        }
        .task-card:hover { z-index: 200 !important; border-color: #fff; box-shadow: 0 5px 20px #000; }
        .task-card.is-robot { background: rgba(80, 70, 20, 0.95); border: 1px solid var(--robot-gold); box-shadow: 0 0 5px rgba(255, 215, 0, 0.2); }
        .task-card.is-robot .bar-real { background-color: var(--robot-gold); }

        .bar-planned { position: absolute; width: 4px; left: 0; background: #555; opacity: 0.8; height: 100%; }
        .bar-real { position: absolute; width: 5px; left: 4px; background: #4caf50; height: 100%; }
        
        .task-label { 
            position: absolute; left: 12px; top: 0; height: 100%; 
            display: flex; align-items: center; line-height: 1; 
            font-weight: 600; color: #fff; white-space: nowrap; 
            text-shadow: 0 0 2px #000, 0 0 3px #000, 0 0 4px #000; 
            pointer-events: none; 
            z-index: 999; 
        }
        
        .task-card.summary { background: #1565c0; border: 1px solid rgba(255,255,255,0.3); opacity: 1; display: flex; align-items: center; justify-content: center; }
        .summary .task-label { position: relative; left: 0; text-align: center; font-size: 9px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; width: 100%; display: block; }

        #connections { position: absolute; top: 55px; left: var(--ruler-width); pointer-events: none; z-index: 5; }
        path.arrow { fill: none; stroke: #666; stroke-width: 1; opacity: 0.3; pointer-events: auto; cursor: pointer; transition: 0.1s; }
        path.arrow:hover { stroke: #fff; opacity: 1; stroke-width: 2; }
        path.arrow.active { stroke: #fff !important; opacity: 1 !important; stroke-width: 3px !important; }

        .has-highlight .task-card { opacity: 0.15; filter: grayscale(100%); }
        .has-highlight path.arrow { opacity: 0.05; }
        
        .has-highlight .task-card.parent { opacity: 1; filter: none; border-color: var(--highlight-parent); z-index: 900; }
        .has-highlight .task-card.child { opacity: 1; filter: none; border-color: var(--highlight-child); z-index: 900; }
        
        .has-highlight .task-card.active { opacity: 1; filter: none; border-color: #fff; z-index: 1000 !important; background: #333; }
        .has-highlight .task-card.active.is-robot { background: rgba(100, 80, 10, 1); border-color: #fff; }

        .has-highlight path.arrow.parent { opacity: 1; stroke: var(--highlight-parent); stroke-width: 2; }
        .has-highlight path.arrow.child { opacity: 1; stroke: var(--highlight-child); stroke-width: 2; }
        .has-lock .task-card.active { border: 2px solid #fff; box-shadow: 0 0 15px var(--accent); }

        #overlay-layer { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events: none; z-index: 1001; }
        .selection-box { position: absolute; background: rgba(255, 255, 255, 0.15); border: 2px solid #fff; border-top: none; border-bottom: none; box-shadow: inset 0 0 20px rgba(255,255,255,0.1); animation: flash 0.5s ease-out; }
        @keyframes flash { from { background: rgba(255,255,255,0.5); } to { background: rgba(255,255,255,0.15); } }
    </style>
</head>
<body>

<div id="sidebar">
    <div><h2>FRC Schedule v49</h2><div class="subtitle">Stable & Fixed</div></div>
    <div class="step-box"><label>1. Upload CSV</label><input type="file" id="csvInput" accept=".csv"><div id="status" style="font-size:12px; margin-top:5px; color:#aaa;">Waiting...</div></div>
    <div class="step-box"><label>2. Actions</label><button id="renderBtn" class="action-btn" onclick="processAndRender()" disabled>RENDER</button><button id="downloadBtn" class="action-btn" onclick="downloadSchedule()" disabled>DOWNLOAD HTML</button></div>
</div>

<div id="main-area">
    <div class="top-bar">
        <div style="display:flex; align-items:center;">
            <button class="sidebar-toggle" onclick="toggleSidebar()" title="Toggle Sidebar">â˜°</button>
            <div class="view-controls">
                <button class="view-tab active" onclick="switchView('combined', this)">Combined</button>
                <button class="view-tab" onclick="switchView('summary', this)">Summary</button>
                <button class="view-tab" onclick="switchView('detail', this)">Detail</button>
            </div>
        </div>
        <div class="zoom-controls">
            <div class="zoom-group">
                <span>H</span>
                <input type="range" id="widthSlider" min="50" max="400" value="220" oninput="updateZoom()">
            </div>
            <div class="zoom-group">
                <span>V</span>
                <input type="range" id="heightSlider" min="10" max="120" value="40" oninput="updateZoom()">
            </div>
            <div class="zoom-group">
                <span>T</span>
                <input type="range" id="textSlider" min="8" max="24" value="11" oninput="updateZoom()">
            </div>
            <div class="legend-item"><div class="dot" style="background:#4caf50"></div>Real</div>
            <div class="legend-item"><div class="dot" style="background:var(--robot-gold)"></div>Robot</div>
        </div>
    </div>
    <div id="viewport-container">
        <div id="combined-view" class="view-pane active">
            <div class="cv-top"><div id="cv-summary" class="gantt-viewport" style="overflow:hidden;"></div></div>
            <div id="drag-handle" title="Drag to resize"></div>
            <div class="cv-bottom"><div id="cv-detail" class="gantt-viewport"></div></div>
        </div>
        <div id="summary-full" class="view-pane"><div id="sv-full" class="gantt-viewport"></div></div>
        <div id="detail-full" class="view-pane"><div id="dv-full" class="gantt-viewport"></div></div>
    </div>
</div>

<script>
let detailData = [], summaryData = [];
// Initial defaults
let BASE_COL_WIDTH = 220; 
let BASE_HEIGHT = 40;
let TEXT_SIZE = 11;
const RULER_WIDTH = 40;

let parentsOf = {}, childrenOf = {};
let lockedIds = new Set();
let isResizing = false;
let arrowsTimeout = null;

// Initialize Splitter Logic
(function initSplitter() {
    const handle = document.getElementById('drag-handle');
    const container = document.getElementById('combined-view');
    const topPane = document.querySelector('.cv-top');
    
    handle.addEventListener('mousedown', function(e) {
        e.preventDefault();
        isResizing = true;
        document.body.style.cursor = 'row-resize';
    });

    document.addEventListener('mousemove', function(e) {
        if (!isResizing) return;
        const containerRect = container.getBoundingClientRect();
        let newHeight = e.clientY - containerRect.top;
        if (newHeight < 50) newHeight = 50;
        if (newHeight > containerRect.height - 50) newHeight = containerRect.height - 50;
        
        const percent = (newHeight / containerRect.height) * 100;
        topPane.style.flex = `0 0 ${percent}%`;
    });

    document.addEventListener('mouseup', function(e) {
        if (isResizing) {
            isResizing = false;
            document.body.style.cursor = '';
            if (document.getElementById('combined-view').classList.contains('active')) {
                renderInstance(summaryData, 'cv-summary', true, true, true);
            }
        }
    });
})();

function toggleSidebar() {
    document.getElementById('sidebar').classList.toggle('hidden');
}

function sanitizeId(str) { return str.replace(/[^a-zA-Z0-9]/g, '_'); }

const parseDate = (dStr) => { 
    if(!dStr || typeof dStr !== 'string') return null; 
    try {
        const parts = dStr.split('/'); 
        if(parts.length === 3) {
            const dt = new Date(parseInt(parts[2]), parseInt(parts[0]) - 1, parseInt(parts[1])); 
            dt.setHours(0,0,0,0);
            if(isNaN(dt.getTime())) return null;
            return dt;
        }
    } catch(e) {}
    return null; 
};
const getDateKey = (d) => (!d || isNaN(d.getTime())) ? "INVALID" : `${d.getFullYear()}-${d.getMonth()}-${d.getDate()}`;

document.getElementById('csvInput').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        window.rawCSV = e.target.result; 
        document.getElementById('status').innerText = `Loaded.`;
        document.getElementById('renderBtn').disabled = false;
        
        updateZoom(false); 
        processAndRender();
    };
    reader.readAsText(file);
});

function splitCSVLine(text) {
    const re_value = /(?!\s*$)\s*(?:'([^']*)'|"([^"]*)"|([^,'"\s\\]*(?:\s+[^,'"\s\\]+)*))\s*(?:,|$)/g;
    const a = []; text.replace(re_value, function(m0, m1, m2, m3) {
        if (m1 !== undefined) a.push(m1.replace(/\\'/g, "'"));
        else if (m2 !== undefined) a.push(m2.replace(/\\"/g, '"'));
        else if (m3 !== undefined) a.push(m3);
        return '';
    });
    if (/,\s*$/.test(text)) a.push('');
    return a;
}

function processCSV(csvContent) {
    const rows = csvContent.split(/\r\n|\n/);
    const data = [];
    const rowIdToUUID = {}; 
    let currentGroup = null; 
    let currentMainColName = ""; 
    
    let headerRowIndex = -1, predColIndex = -1, robotColIndex = -1, planStartColIndex = -1;
    for(let i=0; i<Math.min(20, rows.length); i++) {
        if(rows[i].includes("Item Description")) {
            headerRowIndex = i;
            const cols = splitCSVLine(rows[i]);
            cols.forEach((c, idx) => {
                const txt = c.toLowerCase().trim();
                if(txt.includes("predecessors")) predColIndex = idx;
                if(txt.includes("machine resource") || txt.includes("robot")) robotColIndex = idx;
                if(txt.includes("start date") && planStartColIndex === -1) planStartColIndex = idx;
            });
            break;
        }
    }
    if (predColIndex === -1) predColIndex = 14; 
    if (planStartColIndex === -1) planStartColIndex = 5;

    const getOrAddCol = (grp, name) => {
        let c = grp.cols.find(x => x.name === name);
        if(!c) { c = { name: name, tasks: [] }; grp.cols.push(c); }
        return c;
    };

    rows.forEach((line, index) => {
        if (!line || line.trim() === '') return;
        if (index <= headerRowIndex) return;
        const cols = splitCSVLine(line);
        const rowId = cols[0]; if(!rowId) return;
        const t1 = cols[1]&&cols[1].trim(); 
        const t2 = cols[2]&&cols[2].trim();
        const t3 = cols[3]&&cols[3].trim(); 
        const t4 = cols[4]&&cols[4].trim();
        
        let dateStartIndex = planStartColIndex;
        if(!cols[dateStartIndex] || !cols[dateStartIndex].includes('/')) {
             for(let i=3; i<10; i++) { if(cols[i] && cols[i].match(/^\d{1,2}\/\d{1,2}\/\d{4}/)) { dateStartIndex = i; break; } }
        }
        const hasDates = (dateStartIndex > -1 && cols[dateStartIndex] && cols[dateStartIndex].includes('/'));

        if (t1) {
            currentGroup = { name: t1, cols: [], id: rowId }; data.push(currentGroup); 
            currentMainColName = ""; return;
        }
        if (t2) {
            if (!currentGroup) { currentGroup = { name: "General", cols: [], id: "gen" }; data.push(currentGroup); }
            currentMainColName = t2; getOrAddCol(currentGroup, t2); return; 
        }

        let isLeaf = true;
        if (index + 1 < rows.length) {
            const nextCols = splitCSVLine(rows[index+1]);
            const n4 = nextCols[4]&&nextCols[4].trim();
            if (t3 && !t4 && n4) isLeaf = false;
        }

        if (!currentGroup) { currentGroup = { name: "General", cols: [], id: "gen" }; data.push(currentGroup); }

        if (!isLeaf) { getOrAddCol(currentGroup, t3); return; }

        if (hasDates) {
            let taskName = t4 ? t4 : t3;
            let targetColName = currentMainColName;
            if (t4) {
                if(currentGroup.cols.length > 0) targetColName = currentGroup.cols[currentGroup.cols.length-1].name;
            } else if (t3) { targetColName = currentMainColName; }

            const col = getOrAddCol(currentGroup, targetColName);
            const task = createTask(cols, rowId, taskName, dateStartIndex, predColIndex, robotColIndex);
            
            if (task.n !== col.name && task.sObj) {
                col.tasks.push(task); 
                rowIdToUUID[rowId] = task.id;
            }
        }
    });

    data.forEach(g => { g.cols = g.cols.filter(c => c.tasks.length > 0 || c.name === "General"); });

    data.forEach(g => g.cols.forEach(c => c.tasks.forEach(t => {
        if (t.rawDeps) {
            const depIds = t.rawDeps.replace(/"/g, '').split(/[, ]+/);
            t.dep = [];
            depIds.forEach(dVal => {
                const dClean = dVal.trim();
                if (dClean && rowIdToUUID[dClean]) t.dep.push(rowIdToUUID[dClean]);
            });
            delete t.rawDeps; 
        }
    })));

    return data;
}

function createTask(cols, rowId, name, dateIdx, predIdx, robotIdx) {
    let isRobot = (robotIdx > -1 && cols[robotIdx] && cols[robotIdx].trim().length > 0);
    if (robotIdx > -1 && cols[robotIdx] && (cols[robotIdx].toLowerCase().includes('yes') || cols[robotIdx].toLowerCase().includes('true'))) isRobot = true;
    let predString = ""; if (predIdx > -1 && cols[predIdx]) { const val = cols[predIdx].trim(); if(val.match(/^[\d, ]+$/)) predString = val; }
    const sObj = parseDate(cols[dateIdx]); const eObj = parseDate(cols[dateIdx+1]);
    const rsObj = parseDate(cols[dateIdx+3]) || sObj; const reObj = parseDate(cols[dateIdx+4]) || eObj; 
    return { id: "task_" + rowId, n: name.replace(/"/g, ''), sObj: sObj, eObj: eObj, rsObj: rsObj, reObj: reObj, rob: isRobot, rawDeps: predString };
}

function processAndRender() {
    if(!window.rawCSV) return;
    detailData = processCSV(window.rawCSV);
    summaryData = detailData.map(g => {
        const sumCols = g.cols.map(c => {
            let minS = null; let maxE = null;
            c.tasks.forEach(t => { if(!t.sObj) return; if(!minS || t.sObj < minS) minS = t.sObj; if(!maxE || t.eObj > maxE) maxE = t.eObj; });
            if(!minS) return null;
            return { name: c.name, tasks: [{ id: sanitizeId(c.name + '_sum'), n: c.name, sObj: minS, eObj: maxE, rsObj: minS, reObj: maxE, rob: false }] };
        }).filter(x => x !== null);
        return { name: g.name, cols: sumCols };
    });
    
    parentsOf = {}; childrenOf = {};
    const taskMap = {};
    detailData.forEach(g => g.cols.forEach(c => c.tasks.forEach(t => { 
        if(!t.sObj || !t.eObj) return; 
        t.visualStart = (t.sObj < t.rsObj) ? t.sObj : t.rsObj; t.visualEnd = (t.eObj > t.reObj) ? t.eObj : t.reObj;
        taskMap[t.id] = t;
    })));
    
    detailData.forEach(g => g.cols.forEach(c => c.tasks.forEach(t => { 
        if(t.dep) {
            parentsOf[t.id] = t.dep; 
            t.dep.forEach(p => { 
                if(!childrenOf[p]) childrenOf[p]=[]; childrenOf[p].push(t.id);
                const parent = taskMap[p];
                if(parent && parent.visualEnd && t.visualStart && getDateKey(parent.visualEnd) === getDateKey(t.visualStart)) {
                    parent.isAM = true; 
                    t.isPM = true;
                }
            }); 
        }
    })));
    summaryData.forEach(g => g.cols.forEach(c => c.tasks.forEach(t => { t.visualStart = t.sObj; t.visualEnd = t.eObj; })));
    renderCurrentView(); document.getElementById('downloadBtn').disabled = false;
}

function switchView(mode, btn) {
    document.querySelectorAll('.view-tab').forEach(b => b.classList.remove('active')); btn.classList.add('active');
    document.querySelectorAll('.view-pane').forEach(el => { el.style.display = 'none'; el.classList.remove('active'); });
    if(mode === 'combined') { const el = document.getElementById('combined-view'); el.style.display = 'flex'; el.classList.add('active'); }
    if(mode === 'summary') { const el = document.getElementById('summary-full'); el.style.display = 'block'; el.classList.add('active'); }
    if(mode === 'detail') { const el = document.getElementById('detail-full'); el.style.display = 'block'; el.classList.add('active'); }
    renderCurrentView();
}

function renderCurrentView() {
    if(!detailData || detailData.length === 0) return;
    try {
        if(document.getElementById('combined-view').classList.contains('active')) {
            renderInstance(summaryData, 'cv-summary', true, true, true); 
            renderInstance(detailData, 'cv-detail', false, false, false);
        } else if(document.getElementById('summary-full').classList.contains('active')) {
            renderInstance(summaryData, 'sv-full', true, false, false);
        } else {
            renderInstance(detailData, 'dv-full', false, false, false);
        }
        
        // Ensure highlight persists if set
        if(lockedIds.size > 0) {
            highlightAll();
        }
    } catch(e) {
        console.error("Render error:", e);
    }
}

function updateZoom(shouldRender = true) { 
    const hVal = document.getElementById('heightSlider').value;
    const wVal = document.getElementById('widthSlider').value;
    const tVal = document.getElementById('textSlider').value;
    
    BASE_HEIGHT = parseInt(hVal); 
    BASE_COL_WIDTH = parseInt(wVal);
    TEXT_SIZE = parseInt(tVal);
    
    if(shouldRender) renderCurrentView(); 
}

function precalcY(minDate, maxDate, isSummary, fitHeight) {
    const map = {}; let currentY = 0; let d = new Date(minDate); 
    let pxPerDay = 30; 
    if (fitHeight && isSummary) {
        const msPerDay = 1000 * 60 * 60 * 24;
        const totalDays = (maxDate - minDate) / msPerDay;
        const available = fitHeight - 55; 
        pxPerDay = available / totalDays;
    } else {
        pxPerDay = isSummary ? 30 : BASE_HEIGHT;
    }

    let loops = 0;
    while(d <= maxDate && loops < 5000) {
        let weight = 1.0; const day = d.getDay();
        if (!isSummary) { if (day === 1 || day === 3) weight = 2.0; else if (day === 6) weight = 4.0; else weight = 1.0; }
        const h = (fitHeight) ? pxPerDay : (pxPerDay * weight);
        map[getDateKey(d)] = { top: currentY, height: h, day: day };
        currentY += h; d.setDate(d.getDate() + 1); loops++;
    }
    return { map, totalH: currentY };
}
function getY(dateObj, map) { if(!dateObj) return 0; const k = getDateKey(dateObj); return map[k] ? map[k].top : 0; }
function getHeightForDate(dateObj, map) { if(!dateObj) return 20; const k = getDateKey(dateObj); return map[k] ? map[k].height : 20; }
function getHeight(sObj, eObj, map) {
    if(!sObj || !eObj) return 20; let total = 0; let curr = new Date(sObj); const eTime = eObj.getTime(); let loops = 0;
    while(curr.getTime() <= eTime && loops < 1000) { const k = getDateKey(curr); if (map[k]) total += map[k].height; curr.setDate(curr.getDate() + 1); loops++; }
    return Math.max(total, (map[getDateKey(sObj)] ? map[getDateKey(sObj)].height : 20)); 
}

function renderInstance(data, containerId, isSummary, fitY, fitX) {
    const vp = document.getElementById(containerId); 
    if(!vp) return;
    vp.innerHTML = '';
    if(!isSummary) vp.onwheel = (evt) => { if (evt.shiftKey) { evt.preventDefault(); vp.scrollLeft += evt.deltaY; } };

    let minDate = null; let maxDate = null;
    const scanData = summaryData; 
    let hasData = false;
    scanData.forEach(g => g.cols.forEach(col => col.tasks.forEach(t => {
        if(t.visualStart && t.visualEnd) {
            if(t.visualStart.getFullYear() < 2026) return;
            if(!minDate || t.visualStart < minDate) minDate = t.visualStart;
            if(!maxDate || t.visualEnd > maxDate) maxDate = t.visualEnd;
            hasData = true;
        }
    })));
    
    if(!hasData || !minDate) { vp.innerHTML = '<div style="padding:20px;color:#666">No valid 2026+ tasks.</div>'; return; }

    const dMin = new Date(minDate); dMin.setDate(dMin.getDate() - 2);
    const dMax = new Date(maxDate); dMax.setDate(dMax.getDate() + 5);
    
    let containerH = 0; if(fitY) containerH = vp.clientHeight;
    const { map, totalH } = precalcY(dMin, dMax, isSummary, containerH);
    vp.dataset.scrollHeight = totalH;

    const ruler = document.createElement('div'); ruler.className = 'date-ruler'; ruler.style.height = (totalH + 60) + "px"; 
    const body = document.createElement('div'); body.className = 'chart-body'; body.style.height = (totalH + 60) + "px";
    vp.appendChild(ruler); vp.appendChild(body);
    
    const overlayLayer = document.createElement('div'); overlayLayer.id = 'overlay-layer'; body.appendChild(overlayLayer);

    const headerStack = document.createElement('div'); headerStack.className = 'header-stack';
    const rowGroups = document.createElement('div'); rowGroups.className = 'header-row-groups';
    const rowCols = document.createElement('div'); rowCols.className = 'header-row-cols';
    headerStack.appendChild(rowGroups); headerStack.appendChild(rowCols);
    body.appendChild(headerStack);

    let curr = new Date(dMin);
    const tickContainer = document.createElement('div'); tickContainer.className = 'tick-container'; body.appendChild(tickContainer);

    let loops = 0;
    while(curr <= dMax && loops < 5000) {
        const k = getDateKey(curr); const params = map[k];
        if(params) {
            const day = params.day; const isSat = (day===6); const isMeet = (day===1 || day===3 || day===6);
            let showTick = false;
            if (fitY && isSummary) { if (isSat) showTick = true; } else if (!isSummary || isSat) { showTick = true; }

            if(showTick && params.height > 8) {
                const tick = document.createElement('div'); tick.className = `date-tick ${isSat?'sat':''}`;
                tick.style.top = (params.top + 55) + "px"; tick.style.height = params.height + "px";
                if(fitY) tick.innerHTML = `${curr.getMonth()+1}/${curr.getDate()}`;
                else tick.innerHTML = `<span>${curr.getMonth()+1}/${curr.getDate()}</span>`;
                ruler.appendChild(tick);
            }
            const band = document.createElement('div'); band.className = `day-band ${isMeet?'meeting':''}`;
            band.style.top = (params.top + 55) + "px"; band.style.height = params.height + "px";
            tickContainer.appendChild(band);
        }
        curr.setDate(curr.getDate() + 1); loops++;
    }

    const laneCont = document.createElement('div'); laneCont.className = 'swimlane-container'; body.appendChild(laneCont);

    let totalCols = 0; data.forEach(g => totalCols += g.cols.length);
    let fitColW = 0;
    if(fitX) {
        fitColW = (vp.clientWidth - RULER_WIDTH) / totalCols;
    }

    let totalW = RULER_WIDTH; 
    
    const labelStyle = `font-size:${TEXT_SIZE}px;`;

    data.forEach(g => {
        let groupW = 0;
        g.cols.forEach(c => {
             if(fitX) c.renderWidth = fitColW;
             else { 
                 c.maxSlots = calculateSlots(c.tasks); 
                 const slotWidth = Math.max(50, BASE_COL_WIDTH * 0.25);
                 c.renderWidth = Math.max(BASE_COL_WIDTH, c.maxSlots * slotWidth); 
             }
             groupW += c.renderWidth;
        });

        const gh = document.createElement('div'); gh.className = 'group-header'; gh.style.width = groupW + "px"; gh.innerText = g.name; rowGroups.appendChild(gh);
        
        g.cols.forEach(c => {
            const ch = document.createElement('div'); ch.className = 'col-header'; ch.style.width = c.renderWidth + "px"; ch.innerText = c.name; rowCols.appendChild(ch);
            const lane = document.createElement('div'); lane.className = 'swimlane'; lane.style.width = c.renderWidth + "px";
            const safeName = sanitizeId(c.name);
            lane.classList.add('lane-target-' + safeName);
            
            if(isSummary) lane.onclick = () => { scrollToDetail(c.name); if(c.tasks.length>0) showOverlay(c.name, c.tasks[0].sObj, c.tasks[0].eObj, map); };

            c.tasks.forEach(t => {
                if(!t.visualStart || t.visualStart.getFullYear() < 2026) return;
                let cardTop = getY(t.visualStart, map); let cardHeight = getHeight(t.visualStart, t.visualEnd, map);
                
                if(!isSummary) {
                    if (t.isPM) { 
                        const dayH = getHeightForDate(t.visualStart, map); 
                        const offset = dayH * 0.5; cardTop += offset; cardHeight -= offset; 
                    }
                    if (t.isAM) { 
                        const dayH = getHeightForDate(t.visualEnd, map); 
                        cardHeight -= (dayH * 0.5); 
                    }
                }

                const slotW = (c.renderWidth - 10) / (isSummary ? 1 : c.maxSlots);
                const left = isSummary ? 5 : 5 + (t.slot * slotW);
                const card = document.createElement('div');
                card.className = isSummary ? `task-card summary t-${t.id}` : `task-card t-${t.id}`;
                if(t.rob) card.classList.add('is-robot');
                
                card.style.top = cardTop + "px"; card.style.height = cardHeight + "px"; card.style.left = left + "px"; card.style.width = (isSummary ? "90%" : (slotW-5) + "px");
                const planTop = getY(t.sObj, map) - getY(t.visualStart, map);
                const realTop = getY(t.rsObj, map) - getY(t.visualStart, map);
                
                if(isSummary) {
                    card.innerHTML = `<div class="task-label" style="${labelStyle}">${t.n}</div>`;
                    card.onclick = () => { scrollToDetail(c.name); showOverlay(c.name, t.visualStart, t.visualEnd, map); };
                } else {
                    card.innerHTML = `<div class="bar-planned" style="top:${planTop}px"></div><div class="bar-real" style="top:${realTop}px"></div><div class="task-label" style="${labelStyle}">${t.n}</div>`;
                    card.onclick = (e) => { e.stopPropagation(); toggleLock(t.id); };
                    card.onmouseenter = () => { if(lockedIds.size === 0) highlightSingle(t.id); };
                    card.onmouseleave = () => { if(lockedIds.size === 0) unhighlight(); };
                }
                lane.appendChild(card);
            });
            laneCont.appendChild(lane);
        });
        totalW += groupW;
    });

    body.style.width = (totalW + RULER_WIDTH) + "px"; 
    document.querySelectorAll('.day-band').forEach(b => b.style.width = (totalW + RULER_WIDTH) + 'px');

    if(!isSummary) {
        if(arrowsTimeout) clearTimeout(arrowsTimeout);
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.id = 'connections'; svg.style.position='absolute'; svg.style.top='55px'; svg.style.left= RULER_WIDTH + 'px';
        svg.setAttribute('width', (totalW - RULER_WIDTH)); svg.setAttribute('height', totalH);
        body.appendChild(svg);
        arrowsTimeout = setTimeout(() => drawArrows(svg, containerId), 50);
    }
}

function calculateSlots(tasks) {
    const valid = tasks.filter(t => t.visualStart && t.visualStart.getFullYear() >= 2026);
    valid.sort((a,b) => a.visualStart.getTime() - b.visualStart.getTime());
    let slots = [];
    valid.forEach(t => {
        let placed = false;
        for(let i=0; i<slots.length; i++) { if(slots[i] < t.visualStart.getTime()) { t.slot = i; slots[i] = t.visualEnd.getTime(); placed = true; break; } }
        if(!placed) { t.slot = slots.length; slots.push(t.visualEnd.getTime()); }
    });
    return Math.max(1, slots.length);
}

function drawArrows(svg, containerId) {
    if(!document.body.contains(svg)) return; // Safety check
    
    let html = `<defs><marker id="arrow" markerWidth="10" markerHeight="10" refX="10" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="#666" /></marker></defs>`;
    const bodyRect = document.querySelector('#'+containerId+' .chart-body').getBoundingClientRect();
    const xOff = RULER_WIDTH; const yOff = 55;

    Object.keys(parentsOf).forEach(childId => {
        const cEl = document.querySelector('#'+containerId+' .t-'+childId); 
        if(!cEl) return;
        const cRect = cEl.getBoundingClientRect();
        if(cRect.width === 0) return;
        const cX = (cRect.left + cRect.width/2) - bodyRect.left - xOff; const cY = cRect.top - bodyRect.top - yOff;
        parentsOf[childId].forEach(pId => {
            const pEl = document.querySelector('#'+containerId+' .t-'+pId); 
            if(!pEl) return;
            const pRect = pEl.getBoundingClientRect();
            const pX = (pRect.left + pRect.width/2) - bodyRect.left - xOff; const pY = pRect.bottom - bodyRect.top - yOff;
            const distY = cY - pY; const curve = Math.min(60, Math.abs(distY) / 2);
            const d = `M${pX},${pY} C${pX},${pY + curve} ${cX},${cY - curve} ${cX},${cY}`;
            html += `<path class="arrow link-${pId}-${childId}" d="${d}" marker-end="url(#arrow)" onclick="toggleLock('${childId}')" />`;
        });
    });
    svg.innerHTML = html;
    
    // FIX: Apply highlights to newly drawn arrows
    if(lockedIds.size > 0) {
        highlightAll();
    }
}

function toggleLock(id) { 
    if (lockedIds.has(id)) {
        lockedIds.delete(id);
    } else {
        lockedIds.add(id);
    }

    if (lockedIds.size === 0) { 
        document.getElementById('main-area').classList.remove('has-lock'); 
        unhighlight(); 
    } else { 
        document.getElementById('main-area').classList.add('has-lock'); 
        highlightAll(); 
    } 
}

document.addEventListener('keydown', (e) => { 
    if(e.key === "Escape") { 
        lockedIds.clear(); 
        document.getElementById('main-area').classList.remove('has-lock'); 
        unhighlight(); 
    } 
});

function highlightSingle(id) {
    document.getElementById('main-area').classList.add('has-highlight');
    highlightRecursive(id);
}

function highlightAll() {
    unhighlightInternal();
    document.getElementById('main-area').classList.add('has-highlight');
    lockedIds.forEach(id => {
        highlightRecursive(id);
    });
}

function highlightRecursive(id) {
    document.querySelectorAll('.t-'+id).forEach(el => el.classList.add('active'));
    
    const traceUp = (curr) => { if(parentsOf[curr]) parentsOf[curr].forEach(p => { 
        document.querySelectorAll('.t-'+p).forEach(el => el.classList.add('parent'));
        document.querySelectorAll(`.link-${p}-${curr}`).forEach(el => el.classList.add('parent'));
        traceUp(p); 
    }); };
    
    const traceDown = (curr) => { if(childrenOf[curr]) childrenOf[curr].forEach(c => { 
        document.querySelectorAll('.t-'+c).forEach(el => el.classList.add('child'));
        document.querySelectorAll(`.link-${curr}-${c}`).forEach(el => el.classList.add('child'));
        traceDown(c); 
    }); };
    
    traceUp(id); traceDown(id);
}

function unhighlightInternal() {
    document.querySelectorAll('.active, .parent, .child').forEach(e => e.classList.remove('active', 'parent', 'child'));
}

function unhighlight() { 
    document.getElementById('main-area').classList.remove('has-highlight'); 
    unhighlightInternal();
}

function scrollToDetail(colName) { const laneClass = '.lane-target-' + sanitizeId(colName); const lane = document.querySelector('#cv-detail ' + laneClass); if(lane) lane.scrollIntoView({ behavior: 'smooth', inline: 'center' }); }
function showOverlay(colName, sObj, eObj, map) {
    document.querySelectorAll('.selection-box').forEach(e => e.remove());
    const overlayLayer = document.querySelector('#cv-detail #overlay-layer');
    if(!overlayLayer) return;
    const laneClass = '.lane-target-' + sanitizeId(colName);
    const lane = document.querySelector('#cv-detail ' + laneClass);
    if(!lane) return;
    const y = 55; const h = overlayLayer.clientHeight - 55; 
    const x = lane.offsetLeft + RULER_WIDTH; const w = lane.offsetWidth;
    const box = document.createElement('div');
    box.className = 'selection-box';
    box.style.top = y + 'px'; box.style.height = h + 'px'; box.style.left = x + 'px'; box.style.width = w + 'px';
    overlayLayer.appendChild(box);
    setTimeout(() => box.style.opacity = 0, 1500); setTimeout(() => box.remove(), 2000);
}
function downloadSchedule() {
    const docContent = document.documentElement.outerHTML;
    const blob = new Blob([docContent], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'frc_schedule_v49.html'; a.click(); URL.revokeObjectURL(url);
}
</script>
</body>
</html>