<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FRC Schedule Generator Tool</title>
    <style>
        :root {
            --bg: #121212;
            --panel: #1e1e1e;
            --border: #333;
            --text: #ddd;
            --accent: #4caf50;
            --btn-hover: #45a049;
            --btn-secondary: #333;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        
        /* --- SIDEBAR --- */
        #sidebar {
            width: 400px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 15px;
            overflow-y: auto;
            flex-shrink: 0;
            transition: margin-left 0.3s ease;
        }
        
        /* HIDE SIDEBAR STATE */
        body.fullscreen #sidebar {
            margin-left: -441px; /* width + padding + border */
        }

        h2 { margin: 0 0 10px 0; font-size: 18px; color: #fff; }
        label { font-size: 12px; font-weight: bold; color: #888; display: block; margin-bottom: 5px; }
        
        textarea {
            width: 100%;
            background: #111;
            border: 1px solid #444;
            color: #eee;
            padding: 10px;
            border-radius: 4px;
            resize: vertical;
            font-family: monospace;
            font-size: 11px;
            box-sizing: border-box;
        }
        
        button, .btn-link {
            display: block;
            width: 100%;
            padding: 12px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            text-align: center;
            text-decoration: none;
            box-sizing: border-box;
            transition: 0.2s;
            font-size: 13px;
        }
        button:hover, .btn-link:hover { background: var(--btn-hover); }
        
        .btn-secondary { background: var(--btn-secondary); border: 1px solid #555; }
        .btn-secondary:hover { background: #444; }
        
        .btn-download { background: #2196f3; margin-top: 5px;}
        .btn-download:hover { background: #1976d2; }

        .step { border-bottom: 1px solid #333; padding-bottom: 15px; margin-bottom: 10px; }

        /* --- PREVIEW AREA --- */
        #preview-container {
            flex-grow: 1;
            background: #000;
            position: relative;
        }
        iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        #placeholder {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #444;
            text-align: center;
        }

        /* --- TOGGLE BUTTON --- */
        #toggle-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(50,50,50,0.8);
            border: 1px solid #555;
            color: white;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        #toggle-btn:hover { background: #444; }

    </style>
</head>
<body>

    <!-- SIDEBAR -->
    <div id="sidebar">
        <div style="text-align:center; color:#fff; font-weight:bold; font-size:20px; margin-bottom:10px;">
            FRC Schedule Builder
        </div>

        <div class="step">
            <label>STEP 1: PASTE SPREADSHEET DATA (B7:N???)</label>
            <textarea id="userInput" rows="6" placeholder="Paste specific tasks, dates, or spreadsheet cells here..."></textarea>
            <div style="height:10px;"></div>
            <button class="btn-secondary" onclick="copyFullPrompt()">1. Copy Prompt + Data</button>
            <div style="text-align:center; margin:5px 0; font-size:11px; color:#666;">(Copied to Clipboard)</div>
        </div>

        <div class="step">
            <label>STEP 2: GENERATE JSON</label>
            <a href="https://aistudio.google.com/" target="_blank" class="btn-link">2. Open Google AI Studio ↗</a>
            <div style="font-size:10px; color:#666; margin-top:5px;">Paste. Copy the &lt;script&gt; code back.</div>
        </div>

        <div class="step">
            <label>STEP 3: VISUALIZE</label>
            <textarea id="aiOutput" rows="6" placeholder="Paste the AI's <script> block here..."></textarea>
            <div style="height:10px;"></div>
            <button onclick="renderFinal()">3. RENDER PREVIEW</button>
            <button class="btn-download" onclick="downloadSchedule()">⬇ DOWNLOAD HTML FILE</button>
            <p>If you see like blocks of color, paste an image of that into gemini, tell it to fix, revisualize</p>
        </div>
        
        <div style="font-size:10px; color:#444; margin-top:auto;">
            Engine v5.0 | No-Overlap Protocol
        </div>
    </div>

    <!-- MAIN AREA -->
    <div id="preview-container">
        <button id="toggle-btn" onclick="toggleSidebar()" title="Toggle Sidebar">◀</button>
        <div id="placeholder">
            <h3>Chart Preview</h3>
            <p>Paste AI output and click Render.</p>
        </div>
        <iframe id="chartFrame"></iframe>
    </div>

<script>
/* ==========================================
   THE GOD MODE SYSTEM PROMPT
   ========================================== */
const SYSTEM_PROMPT_TEXT = `
# SYSTEM PROMPT: FRC SCHEDULE GENERATOR (FULL CONTEXT MODE)

**ROLE:**
You are the **FRC Schedule Compilation Engine**. You are a backend processor. You do not explain yourself. You do not summarize. You accept raw project data and output **only** the Javascript data block required to run the specific HTML Gantt Chart Engine provided below.

**CRITICAL INSTRUCTION:**
The user **ALREADY HAS** the HTML file. Do **NOT** regenerate the HTML. Do **NOT** regenerate the CSS.
Your **ONLY** output is a \`<script>\` block containing the \`const data = [...]\` array and the final \`renderSchedule(data);\` command.

---

## PART 1: THE RUNTIME ENVIRONMENT (FULL SOURCE CODE)
*You must read, analyze, and understand every line of the code below. This is the actual engine the user is running. If you generate data that contradicts the variable names or logic in this code, the system will crash. Pay specific attention to the \`parseDate\` function and the object keys used in the \`renderSchedule\` loop.*

\`\`\`javascript
// 1. DATE PARSING
// The engine uses a strict manual parser. 
// Input strings MUST be "MM/DD/YYYY" (e.g., "01/10/2026").
// ISO Dates ("2026-01-10") or Text Dates ("Jan 10") will return Invalid Date.
const parseDate = (dStr) => {
    if(!dStr) return new Date();
    const parts = dStr.split('/'); // Expects [MM, DD, YYYY]
    if(parts.length !== 3) return new Date(); 
    // Month is 0-indexed in JS (parts[0] - 1)
    const dt = new Date(parseInt(parts[2]), parseInt(parts[0]) - 1, parseInt(parts[1]));
    dt.setHours(0,0,0,0);
    return dt;
};

// 2. RENDERING LOOP & VARIABLES
// The engine iterates through the JSON structure you generate.
// It expects these EXACT keys.
col.tasks.forEach(t => {
    // t.n   = Task Name (String)
    // t.s   = Planned Start (String "MM/DD/YYYY")
    // t.e   = Planned End (String "MM/DD/YYYY")
    // t.rs  = Real Start (String "MM/DD/YYYY")
    // t.re  = Real End (String "MM/DD/YYYY")
    // t.rob = Robot Required? (Boolean)
    // t.dep = Dependencies (Array of Strings)
    // t.id  = Unique ID (String)
    
    t.sObj = parseDate(t.s);
    t.eObj = parseDate(t.e);
    // ...
});

// 3. COLLISION ALGORITHM (THE "TETRIS" LOGIC)
// The engine sorts tasks by start date.
// If Task B starts before Task A ends, they are placed side-by-side.
// CRITICAL: If you stack 10 tasks on the same start date, the columns become illegibly thin.
col.tasks.sort((a,b) => a.visualStart - b.visualStart);
\`\`\`

---

# SECTION 2: DATA INTEGRITY PROTOCOLS (VISUAL SAFETY)

**CRITICAL PROTOCOL A: THE "SINGLE-LANE" LAW (ZERO OVERLAP)**
**The Issue:** The renderer sorts tasks by start date. If Task A (Jan 1-5) and Task B (Jan 2-6) coexist in the same column, the engine splits the column width by 50%. If 5 tasks overlap, the column becomes 20% width (unreadable slivers).
**The Strict Rule:** You must **NEVER** allow more than 2 tasks to overlap in the same column. ideally, **ZERO** tasks should overlap.
**The Fix (Auto-Serialization):**
*   **Input Reality:** User data often lists 5 "Prototyping" tasks all running Jan 10 - Jan 20.
*   **Your Job:** You MUST lie to save the chart. You must **serialize** them.
    *   *Bad:* Task A (Jan 10-20), Task B (Jan 10-20), Task C (Jan 10-20).
    *   *Good:* Task A (Jan 10-12) -> Task B (Jan 13-15) -> Task C (Jan 16-18).
*   **Action:** If you see parallel tasks in input, **CHANGE THE DATES** to make them sequential. Readability > Exact Date Accuracy.

### Protocol B: The "Explosion" Prevention
**The Issue:** If a date format is wrong, \`End - Start\` = \`NaN\`.
**The Fix:** Strict \`MM/DD/YYYY\` format. Pad zeros.
---

# SECTION 3: COLUMN TAXONOMY (STRICT MAP)

You must map input data into this exact JSON structure. Do not invent groups.

**Group 1: "Strategy & Design"**
*   \`Strategy\`
*   \`Prototyping\`
*   \`Robot Design\`

**Group 2: "Hardware: Base"**
*   \`Chassis\` (Frame, Drive Train)
*   \`Bumpers\` (Backing, Fabric, Mounting) **<-- SEPARATE COLUMN**
*   \`Electrical\` (Board Layout, Assembly, Mounting) **<-- SEPARATE COLUMN**

**Group 3: "Hardware: Mechanisms"**
*   \`Intake\`
*   \`End Effector\`
*   \`Superstructure\` (Elevator/Arm)
*   \`Endgame\` (Climber)

**Group 4: "Software"**
*   \`Drive/Loc\` (Swerve, Odometry, Vision)
*   \`Subsystems\` (Mechanism Control, PIDs)
*   \`Operator\` (Controls, Dashboard)

**Group 5: "Drive Team"**
*   \`Practice\`

---

# SECTION 4: DEPENDENCY LOGIC (THE "SPIDERWEB" MANDATE)

**Rule 5: AGGRESSIVE CROSS-COLUMN LINKING**
A Gantt chart without arrows is just a calendar. You must generate a "Spiderweb" of dependencies.
**Requirement:** Every task (except the very first start items) **MUST** have a \`dep\` (dependency).
**Requirement:** 80% of your dependencies must be **CROSS-COLUMN**.

**Logic Map (You must strictly enforce these physics):**
1.  **The "Hardware Waterfall":**
    *   \`Design\` (Col 1) --> \`Fabrication/Chassis\` (Col 2)
    *   \`Fabrication\` (Col 2) --> \`Assembly/Mounting\` (Col 2 or 3)
    *   \`Assembly\` (Col 3) --> \`Electrical/Wiring\` (Col 2) **<-- CRITICAL LINK**
2.  **The "Software Barrier":**
    *   Software cannot test until Hardware is wired.
    *   **LINK:** \`Hardware > Intake > Wiring\` --> \`Software > Subsystems > Intake Test\`
    *   **LINK:** \`Hardware > Chassis > Mount Swerve\` --> \`Software > Drive > Basic Dead Reckoning\`
3.  **The "Drive Team Barrier":**
    *   Drive team cannot practice until Software has code.
    *   **LINK:** \`Software > Drive > Teleop Control\` --> \`Drive Team > Practice > Manual Practice\`

**Anti-Blocking Protocol:**
*   **Daisy Chain:** Task A -> Task B -> Task C.
*   **Never Cluster:** Do not have 5 tasks depend on 1 task simultaneously. Spread them out.
---

# SECTION 5: FINAL OUTPUT TEMPLATE

You will return **ONLY** the following code block. No explanation text.

\`\`\`html
<script>
/**
 * FRC SCHEDULE DATA
 * Generated by [AI Name]
 * STRICT FORMAT: MM/DD/YYYY
 */
const data = [
  {
    "name": "Strategy & Design",
    "cols": [
      {
        "name": "Strategy",
        "tasks": [
          { 
            "id": "strat_1", 
            "n": "Analyze Game Manual", 
            "s": "01/10/2026", 
            "e": "01/12/2026", 
            "rs": "01/10/2026", 
            "re": "01/12/2026", 
            "rob": false, 
            "dep": [] 
          }
        ]
      }
      // ... continue structure
    ]
  }
  // ... continue groups
];

// MANDATORY RENDER CALL
renderSchedule(data);
<\/script>
\`\`\`

Human Notes from past experience:
1) Always keep the original text/description of an items
2) Your not thinking deep enough about the linking, drive team needs programming of almost whole bot. Prog needs electrical, electrical needs mechanical. Your job is figuring out at what level can the following team begin to use what was built.
Ie. manual practice requires all of electrical, auto practice requires all of programming. this appies throughout to other teams as well (final auto practice should basically light up everything because everything needs to come together)
No but like FR, software and driveteam pracetice depends on bumpers, electrical, intake end effector, superstructure, and endgame.
`;

/* ==========================================
   THE ENGINE SOURCE (EMBEDDED)
   ========================================== */
const ENGINE_HTML_START = `<!DOCTYPE html>
<html>
<head>
<style>
    :root { --bg: #121212; --lane-bg: #1e1e1e; --lane-alt: #161616; --meeting-band: rgba(255, 255, 255, 0.03); --border: #333; --text: #ddd; --planned: #666; --real: #4caf50; --late: #e53935; --robot: #ffd700; --highlight-parent: #00e676; --highlight-child: #2979ff; }
    body { font-family: 'Segoe UI', Roboto, sans-serif; background: var(--bg); color: var(--text); margin: 0; height: 100vh; overflow: hidden; display: flex; flex-direction: column; user-select: none; }
    header { padding: 0 20px; height: 55px; background: #000; border-bottom: 1px solid var(--border); flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; z-index: 200; }
    .header-controls { display: flex; align-items: center; gap: 20px; }
    .legend { font-size: 11px; display: flex; gap: 15px; color: #aaa; margin-right: 20px; }
    .dot { width: 8px; height: 8px; display: inline-block; margin-right: 5px; border-radius: 2px; }
    .control-group { display: flex; align-items: center; gap: 8px; font-size: 12px; font-weight: 600; color: #ccc; border-right: 1px solid #333; padding-right: 15px; }
    input[type=range] { accent-color: var(--real); cursor: pointer; width: 100px; }
    #gantt-viewport { flex-grow: 1; overflow: auto; position: relative; display: flex; }
    #date-ruler { position: sticky; left: 0; width: 70px; background: #000; border-right: 1px solid var(--border); z-index: 100; flex-shrink: 0; }
    .date-tick { position: absolute; width: 100%; text-align: right; padding-right: 8px; font-size: 10px; color: #555; border-top: 1px solid #222; box-sizing: border-box; line-height: 1.2; }
    .date-tick.is-meeting { color: #fff; font-weight: bold; font-size: 11px; }
    #chart-body { position: relative; }
    #header-stack { position: sticky; top: 0; z-index: 90; background: var(--bg); border-bottom: 1px solid var(--border); }
    .header-row { display: flex; }
    .group-header { background: #252525; border-right: 1px solid #000; border-bottom: 1px solid #444; text-align: center; font-weight: 700; font-size: 12px; color: #fff; height: 25px; line-height: 25px; box-sizing: border-box; }
    .col-header { background: var(--lane-bg); border-right: 1px solid var(--border); text-align: center; font-size: 11px; color: #bbb; height: 30px; line-height: 30px; box-sizing: border-box; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; }
    .swimlane { border-right: 1px solid var(--border); position: relative; background: var(--lane-bg); box-sizing: border-box; height: 100%; }
    .swimlane:nth-child(even) { background: var(--lane-alt); }
    .meeting-band { position: absolute; left: 0; width: 100%; background: var(--meeting-band); border-top: 1px solid rgba(255,255,255,0.05); border-bottom: 1px solid rgba(255,255,255,0.05); pointer-events: none; z-index: 1; }
    .grid-line { position: absolute; left: 0; width: 100%; height: 1px; background: #222; pointer-events: none; }
    .task-card { position: absolute; background: rgba(35,35,35, 0.9); border: 1px solid #444; border-radius: 3px; font-size: 10px; overflow: hidden; z-index: 10; box-sizing: border-box; transition: 0.1s; cursor: pointer; }
    .task-card:hover { z-index: 60 !important; border-color: #fff; background: #333; box-shadow: 0 5px 15px rgba(0,0,0,0.6); }
    .bar-planned { position: absolute; width: 3px; left: 0; background: var(--planned); opacity: 0.8; }
    .bar-real { position: absolute; width: 3px; left: 4px; background: var(--real); }
    .bar-real.late { background: var(--late); }
    .task-label { margin-left: 10px; padding: 2px; height: 100%; display: flex; align-items: center; line-height: 1.1; }
    .vertical-mode .task-label { writing-mode: vertical-rl; text-orientation: mixed; margin-left: 0; margin-top: 12px; width: 100%; align-items: flex-start; }
    .vertical-mode .bar-planned { width: 100%; top: 0; left: 0; height: 5px; }
    .vertical-mode .bar-real { width: 100%; top: 6px; left: 0; height: 5px; }
    .is-robot .task-label { color: var(--robot); font-weight: bold; text-shadow: 0 1px 1px #000; }
    .is-robot .bar-real { background: var(--robot); box-shadow: 0 0 5px var(--robot); }
    #connections { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
    path.arrow { fill: none; stroke: #666; stroke-width: 1; opacity: 0.3; }
    body.dim-mode .task-card { opacity: 0.1; filter: grayscale(100%); }
    body.dim-mode path.arrow { opacity: 0.02; }
    body.dim-mode .task-card.active { opacity: 1; filter: none; border-color: #fff; }
    body.dim-mode .task-card.parent { opacity: 1; filter: none; border-color: var(--highlight-parent); color: var(--highlight-parent); }
    body.dim-mode path.arrow.parent { opacity: 1; stroke: var(--highlight-parent); stroke-width: 2; }
    body.dim-mode .task-card.child { opacity: 1; filter: none; border-color: var(--highlight-child); color: var(--highlight-child); }
    body.dim-mode path.arrow.child { opacity: 1; stroke: var(--highlight-child); stroke-width: 2; }
</style>
</head>
<body>
<header>
    <div style="font-weight:bold; color:white;">FRC 2026 Schedule</div>
    <div class="header-controls">
        <div class="control-group"><input type="checkbox" id="timeDilation" checked><label for="timeDilation">Scale by Hours</label></div>
        <div class="control-group"><label>Zoom:</label><input type="range" id="zoomSlider" min="20" max="120" value="40"></div>
        <div class="legend"><span><span class="dot" style="background:var(--planned)"></span>Plan</span><span><span class="dot" style="background:var(--real)"></span>Real</span><span><span class="dot" style="background:var(--late)"></span>Late</span><span><span class="dot" style="background:var(--robot)"></span>Robot</span><span><span class="dot" style="border:1px solid #555; background:rgba(255,255,255,0.1)"></span>Meeting</span></div>
    </div>
</header>
<div id="gantt-viewport"><div id="date-ruler"></div><div id="chart-body"><svg id="connections"></svg><div id="header-stack"></div><div id="lanes-container" style="display:flex; height: 100%;"></div></div></div>
<script>
let BASE_HEIGHT = 40; const COL_WIDTH = 190; const HEADER_H = 55; 
let globalData = []; let useTimeDilation = true;
let parentsOf = {}; let childrenOf = {}; let dateYMap = {}; 
const parseDate = (dStr) => { if(!dStr) return new Date(); const parts = dStr.split('/'); if(parts.length !== 3) return new Date(); const dt = new Date(parseInt(parts[2]), parseInt(parts[0]) - 1, parseInt(parts[1])); dt.setHours(0,0,0,0); return dt; };
const getDateKey = (d) => \`\${d.getFullYear()}-\${d.getMonth()}-\${d.getDate()}\`;
document.getElementById('zoomSlider').addEventListener('input', (e) => { BASE_HEIGHT = parseInt(e.target.value); renderSchedule(globalData); });
document.getElementById('timeDilation').addEventListener('change', (e) => { useTimeDilation = e.target.checked; renderSchedule(globalData); });
function precalcYPositions(minDate, maxDate) {
    dateYMap = {}; let currentY = HEADER_H; let d = new Date(minDate);
    while(d <= maxDate) {
        let weight = 1.0; const day = d.getDay();
        if (useTimeDilation) { if (day === 1 || day === 3) weight = 2.0; if (day === 6) weight = 4.0; }
        const h = BASE_HEIGHT * weight;
        dateYMap[getDateKey(d)] = { top: currentY, height: h, day: day };
        currentY += h; d.setDate(d.getDate() + 1);
    }
    return currentY; 
}
function getYForDate(dateObj) { const k = getDateKey(dateObj); return dateYMap[k] ? dateYMap[k].top : 0; }
function getHeightForRange(sObj, eObj) {
    let total = 0; let curr = new Date(sObj); const eTime = eObj.getTime();
    while(curr.getTime() <= eTime) { const k = getDateKey(curr); if (dateYMap[k]) total += dateYMap[k].height; curr.setDate(curr.getDate() + 1); }
    return Math.max(total, 5);
}
function renderSchedule(groups) {
    globalData = groups;
    ['lanes-container', 'header-stack', 'date-ruler', 'connections'].forEach(id => document.getElementById(id).innerHTML = '');
    parentsOf = {}; childrenOf = {};
    let minDate = new Date(8640000000000000); let maxDate = new Date(-8640000000000000);
    let totalCols = 0;
    groups.forEach(g => {
        totalCols += g.cols.length;
        g.cols.forEach(col => {
            col.tasks.forEach(t => {
                t.sObj = parseDate(t.s); t.eObj = parseDate(t.e); t.rsObj = parseDate(t.rs); t.reObj = parseDate(t.re);
                [t.sObj, t.eObj, t.rsObj, t.reObj].forEach(dt => { if(dt < minDate) minDate = dt; if(dt > maxDate) maxDate = dt; });
                if(t.dep) { if(!Array.isArray(t.dep)) t.dep = [t.dep]; parentsOf[t.id] = t.dep; t.dep.forEach(pId => { if(!childrenOf[pId]) childrenOf[pId] = []; childrenOf[pId].push(t.id); }); }
                t.visualStart = t.sObj < t.rsObj ? t.sObj : t.rsObj; t.visualEnd = t.eObj > t.reObj ? t.eObj : t.reObj;
            });
            col.tasks.sort((a,b) => a.visualStart.getTime() - b.visualStart.getTime());
            let slots = []; 
            col.tasks.forEach(t => {
                let placed = false;
                for(let i=0; i<slots.length; i++) { if(slots[i].getTime() < t.visualStart.getTime()) { t.slot = i; slots[i] = t.visualEnd; placed = true; break; } }
                if(!placed) { t.slot = slots.length; slots.push(t.visualEnd); }
            });
            col.maxSlots = slots.length;
        });
    });
    const dMin = new Date(minDate); dMin.setDate(dMin.getDate() - 2);
    const dMax = new Date(maxDate); dMax.setDate(dMax.getDate() + 5);
    const totalH = precalcYPositions(dMin, dMax); const totalW = totalCols * COL_WIDTH;
    const chartBody = document.getElementById('chart-body');
    chartBody.style.width = totalW + "px"; chartBody.style.height = totalH + "px";
    document.getElementById('connections').setAttribute('width', totalW); document.getElementById('connections').setAttribute('height', totalH);
    let curr = new Date(dMin);
    while(curr <= dMax) {
        const k = getDateKey(curr); const params = dateYMap[k];
        if(params) {
            const day = params.day; const isMeeting = (day === 1 || day === 3 || day === 6); const isSat = (day === 6);
            if(isMeeting || isSat) {
                const tick = document.createElement('div'); tick.className = \`date-tick \${isMeeting ? 'is-meeting' : ''}\`; tick.style.top = params.top + "px";
                const dNames = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
                tick.innerHTML = \`\${dNames[day]}<br>\${curr.getMonth()+1}/\${curr.getDate()}\${isSat ? "<br><span class='wk-label'>Wk</span>" : ""}\`;
                document.getElementById('date-ruler').appendChild(tick);
            }
            if(isMeeting) { const band = document.createElement('div'); band.className = 'meeting-band'; band.style.top = params.top + "px"; band.style.height = params.height + "px"; document.getElementById('lanes-container').appendChild(band); } 
            else if (day === 0) { const line = document.createElement('div'); line.className = 'grid-line'; line.style.top = params.top + "px"; document.getElementById('lanes-container').appendChild(line); }
        }
        curr.setDate(curr.getDate() + 1);
    }
    const gRow = document.createElement('div'); gRow.className = 'header-row'; const cRow = document.createElement('div'); cRow.className = 'header-row';
    document.getElementById('header-stack').append(gRow, cRow);
    groups.forEach(g => {
        const gh = document.createElement('div'); gh.className = 'group-header'; gh.style.width = (g.cols.length * COL_WIDTH) + "px"; gh.innerText = g.name; gRow.appendChild(gh);
        g.cols.forEach(c => {
            const ch = document.createElement('div'); ch.className = 'col-header'; ch.style.width = COL_WIDTH + "px"; ch.innerText = c.name; cRow.appendChild(ch);
            const lane = document.createElement('div'); lane.className = 'swimlane'; lane.style.width = COL_WIDTH + "px";
            c.tasks.forEach(t => {
                const cardTop = getYForDate(t.visualStart); const cardHeight = getHeightForRange(t.visualStart, t.visualEnd);
                const planTop = getYForDate(t.sObj) - cardTop; const planHeight = getHeightForRange(t.sObj, t.eObj);
                const realTop = getYForDate(t.rsObj) - cardTop; const realHeight = getHeightForRange(t.rsObj, t.reObj);
                const slotW = (COL_WIDTH - 12) / c.maxSlots; const left = 6 + (t.slot * slotW);
                const card = document.createElement('div'); card.id = \`t-\${t.id}\`; card.className = \`task-card \${t.rob ? 'is-robot' : ''}\`;
                card.style.top = cardTop + "px"; card.style.height = cardHeight + "px"; card.style.left = left + "px"; card.style.width = (slotW - 4) + "px";
                if(slotW < 40) card.classList.add('vertical-mode');
                card.innerHTML = \`<div class="bar-planned" style="top:\${planTop}px; height:\${planHeight}px"></div><div class="bar-real \${t.reObj > t.eObj ? 'late' : ''}" style="top:\${realTop}px; height:\${realHeight}px"></div><div class="task-label">\${t.n}</div>\`;
                card.onmouseenter = () => highlight(t.id); card.onmouseleave = unhighlight; lane.appendChild(card);
            });
            document.getElementById('lanes-container').appendChild(lane);
        });
    });
    setTimeout(() => {
        let svgHtml = \`<defs><marker id="arrow" markerWidth="10" markerHeight="10" refX="10" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="#666" /></marker></defs>\`;
        Object.keys(parentsOf).forEach(childId => {
            const cEl = document.getElementById(\`t-\${childId}\`); if(!cEl) return;
            const cRect = cEl.getBoundingClientRect(); const bRect = chartBody.getBoundingClientRect();
            const cX = (cRect.left + cRect.width/2) - bRect.left; const cY = cRect.top - bRect.top;
            parentsOf[childId].forEach(pId => {
                const pEl = document.getElementById(\`t-\${pId}\`); if(!pEl) return;
                const pRect = pEl.getBoundingClientRect();
                const pX = (pRect.left + pRect.width/2) - bRect.left; const pY = pRect.bottom - bRect.top;
                const curve = BASE_HEIGHT * 2; const d = \`M\${pX},\${pY} C\${pX},\${pY + curve} \${cX},\${cY - curve} \${cX},\${cY}\`;
                svgHtml += \`<path id="link-\${pId}-\${childId}" class="arrow" d="\${d}" marker-end="url(#arrow)" />\`;
            });
        });
        document.getElementById('connections').innerHTML = svgHtml;
    }, 50);
}
function highlight(id) { document.body.classList.add('dim-mode'); document.getElementById(\`t-\${id}\`).classList.add('active'); const trace = (curr, dir, cls) => { const list = dir === 'up' ? parentsOf[curr] : childrenOf[curr]; if(list) list.forEach(next => { const el = document.getElementById(\`t-\${next}\`); const lnk = dir === 'up' ? document.getElementById(\`link-\${next}-\${curr}\`) : document.getElementById(\`link-\${curr}-\${next}\`); if(el) el.classList.add(cls); if(lnk) lnk.classList.add(cls); trace(next, dir, cls); }); }; trace(id, 'up', 'parent'); trace(id, 'down', 'child'); }
function unhighlight() { document.body.classList.remove('dim-mode'); document.querySelectorAll('.active, .parent, .child').forEach(e => e.classList.remove('active', 'parent', 'child')); }
<\/script>
</body>
</html>
`;

/* ==========================================
   TOOL LOGIC
   ========================================== */
function copyFullPrompt() {
    const userSheets = document.getElementById('userInput').value;
    const fullText = SYSTEM_PROMPT_TEXT + "\n\nUSER DATA TO PROCESS:\n" + userSheets;
    
    navigator.clipboard.writeText(fullText).then(() => {
        alert("Prompt and Data copied! Now paste this into Google AI Studio.");
    }).catch(err => console.error('Failed to copy', err));
}

function renderFinal() {
    const aiCode = document.getElementById('aiOutput').value;
    const frame = document.getElementById('chartFrame');
    
    // Clean input
    let cleanCode = aiCode.replace(/```html/g, '').replace(/```javascript/g, '').replace(/```/g, '');
    
    // Merge
    const parts = ENGINE_HTML_START.split('</body>');
    const finalHTML = parts[0] + cleanCode + "</body>" + parts[1];
    
    document.getElementById('placeholder').style.display = 'none';
    
    // Auto-hide sidebar on render
    toggleSidebar(true);

    const blob = new Blob([finalHTML], { type: 'text/html' });
    frame.src = URL.createObjectURL(blob);
    
    // Save for download
    window.currentGeneratedHTML = finalHTML;
}

function downloadSchedule() {
    if (!window.currentGeneratedHTML) {
        alert("Please render a schedule first!");
        return;
    }
    const blob = new Blob([window.currentGeneratedHTML], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'frc_schedule.html';
    a.click();
    URL.revokeObjectURL(url);
}

function toggleSidebar(forceHide = false) {
    const body = document.body;
    const btn = document.getElementById('toggle-btn');
    
    if (forceHide) {
        body.classList.add('fullscreen');
        btn.innerHTML = '▶';
    } else {
        body.classList.toggle('fullscreen');
        btn.innerHTML = body.classList.contains('fullscreen') ? '▶' : '◀';
    }
}
</script>

</body>
</html> 